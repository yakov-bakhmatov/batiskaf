use batiskaf::SqlUpsert;
use batiskaf_derive::*;

#[test]
fn test_simple() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct Person {
        #[batiskaf(primary_key)]
        id: i64,
        name: String,
        age: Option<u32>,
    }
    let sql = Person::upsert_statement("person");
    assert_eq!(
        "INSERT INTO person (id, name, age) VALUES (:id, :name, :age) \
        ON CONFLICT (id) DO UPDATE SET name = excluded.name, age = excluded.age",
        sql
    );
}

#[test]
fn test_skip_column() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct Person {
        #[batiskaf(primary_key)]
        id: i64,
        name: String,
        #[batiskaf(skip)]
        age: Option<u32>,
    }
    let sql = Person::upsert_statement("person");
    assert_eq!(
        "INSERT INTO person (id, name) VALUES (:id, :name) \
        ON CONFLICT (id) DO UPDATE SET name = excluded.name",
        sql
    );
}

#[test]
fn test_no_skip_autogenerated() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct Person {
        #[batiskaf(primary_key, autogenerated)]
        id: i64,
        name: String,
        age: Option<u32>,
    }
    let sql = Person::upsert_statement("person");
    assert_eq!(
        "INSERT INTO person (id, name, age) VALUES (:id, :name, :age) \
        ON CONFLICT (id) DO UPDATE SET name = excluded.name, age = excluded.age",
        sql
    );
}

#[test]
fn test_rename_column() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct Request {
        #[batiskaf(primary_key)]
        id: i64,
        #[batiskaf(column = "type")]
        request_type: String,
        data: String,
    }
    let sql = Request::upsert_statement("request");
    assert_eq!(
        "INSERT INTO request (id, type, data) VALUES (:id, :type, :data) \
        ON CONFLICT (id) DO UPDATE SET type = excluded.type, data = excluded.data",
        sql
    );
}

#[test]
fn test_complex_key() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct FieldValue {
        #[batiskaf(primary_key)]
        x: i64,
        #[batiskaf(primary_key)]
        y: i64,
        value: f64,
    }
    let sql = FieldValue::upsert_statement("height");
    assert_eq!(
        "INSERT INTO height (x, y, value) VALUES (:x, :y, :value) \
        ON CONFLICT (x, y) DO UPDATE SET value = excluded.value",
        sql
    );
}

#[test]
fn test_primary_key_only() {
    #[allow(unused)]
    #[derive(SqlUpsert)]
    struct Point {
        #[batiskaf(primary_key)]
        x: i64,
        #[batiskaf(primary_key)]
        y: i64,
    }
    let sql = Point::upsert_statement("point");
    assert_eq!(
        "INSERT INTO point (x, y) VALUES (:x, :y) \
        ON CONFLICT (x, y) DO NOTHING",
        sql
    );
}
