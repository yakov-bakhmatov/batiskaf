use std::collections::{HashMap, HashSet};
use syn::{self, Attribute, Data, Field, Fields, Lit, Meta, NestedMeta};

#[derive(Debug, Default)]
pub(crate) struct Attributes {
    pub word: HashSet<String>,
    pub name_value: HashMap<String, String>,
}

#[derive(Debug, Default)]
pub(crate) struct Column {
    pub attrs: Attributes,
}

impl Column {
    pub fn name(&self) -> String {
        match self.attrs.name_value.get("column") {
            Some(name) => name.clone(),
            None => "".to_string(),
        }
    }
    pub fn primary_key(&self) -> bool {
        self.attrs.word.contains("primary_key")
    }
    pub fn autogenerated(&self) -> bool {
        self.attrs.word.contains("autogenerated")
    }
    pub fn skip(&self) -> bool {
        self.attrs.word.contains("skip")
    }
    pub fn default(&self) -> bool {
        self.attrs.word.contains("default")
    }
}

impl From<&Field> for Column {
    fn from(f: &Field) -> Self {
        let mut attrs = parse_attributes(&f.attrs);
        if !attrs.name_value.contains_key("column") {
            let name = match f.ident {
                Some(ref ident) => ident.to_string(),
                None => "".to_string(), // TODO: error
            };
            attrs.name_value.insert("column".to_string(), name);
        }
        Column { attrs }
    }
}

pub(crate) fn columns(data: &Data) -> Vec<Column> {
    match *data {
        Data::Struct(ref data) => match data.fields {
            Fields::Named(ref fields) => fields.named.iter().map(|f| f.into()).collect(),
            _ => unimplemented!(),
        },
        _ => unimplemented!(),
    }
}

pub(crate) fn columns_with_fields<'a>(data: &'a Data, default: bool) -> Vec<(Column, &'a Field)> {
    let mut xs: Vec<(Column, &'a Field)> = match *data {
        Data::Struct(ref data) => match data.fields {
            Fields::Named(ref fields) => fields.named.iter().map(|f| (f.into(), f)).collect(),
            _ => unimplemented!(),
        },
        _ => unimplemented!(),
    };
    if default {
        for x in xs.iter_mut() {
            x.0.attrs.word.insert("default".to_string());
        }
    }
    xs
}

pub(crate) fn parse_attributes(attrs: &[Attribute]) -> Attributes {
    let mut a = Attributes::default();
    let meta: Vec<Meta> = attributes_to_meta(attrs);
    for m in meta {
        match m {
            Meta::Word(ident) => {
                a.word.insert(ident.to_string());
            }
            Meta::NameValue(name_value) => {
                if let Lit::Str(lit) = name_value.lit {
                    a.name_value
                        .insert(name_value.ident.to_string(), lit.value());
                }
            }
            _ => (),
        }
    }
    a
}

fn attributes_to_meta(attrs: &[Attribute]) -> Vec<Meta> {
    attrs
        .iter()
        .filter_map(|a| a.parse_meta().ok())
        .filter_map(|m| {
            if let Meta::List(meta) = m {
                Some(meta)
            } else {
                None
            }
        })
        .filter(|m| m.ident.to_string().as_str() == "batiskaf")
        .flat_map(|m| m.nested)
        .filter_map(|m| {
            if let NestedMeta::Meta(meta) = m {
                Some(meta)
            } else {
                None
            }
        })
        .collect()
}
